// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct DocumentProfileDescriptorNonBasicDocCharacteristics {
    pub profilecharactersets: Option<ASN1OctetString>,
    pub commentscharactersets: Option<ASN1OctetString>,
    pub alternativereprcharsets: Option<ASN1OctetString>,
    pub pagedimensions: Option<Vec<LayoutDescriptorsDimensionPair>>,
    pub mediumtypes: Option<Vec<LayoutDescriptorsMediumType>>,
    pub layoutpaths: Option<Vec<LayoutDescriptorsOneOfFourAngles>>,
    pub transparencies: Option<Vec<LayoutDescriptorsTransparency>>,
    pub protections: Option<Vec<LogicalDescriptorsProtection>>,
    pub blockalignments: Option<Vec<StyleDescriptorsBlockAlignment>>,
    pub fillorders: Option<Vec<StyleDescriptorsFillOrder>>,
    pub colours: Option<Vec<LayoutDescriptorsColour>>,
    pub coloursoflayoutobject: Option<Vec<ColourAttributesColourExpression>>,
    pub objectcolourtables: Option<Vec<ColourAttributesColourTable>>,
    pub contentbackgroundcolours: Option<Vec<LayoutDescriptorsContentBackgroundColour>>,
    pub contentforegroundcolours: Option<Vec<LayoutDescriptorsContentForegroundColour>>,
    pub contentcolourtables: Option<Vec<ColourAttributesColourTable>>,
    pub borders: Option<Vec<LayoutDescriptorsBorder>>,
    pub pagepositions: Option<Vec<LayoutDescriptorsMeasurePair>>,
    pub typesofcoding: Option<Vec<TextUnitsTypeOfCoding>>,
    pub characterpresentationfeatures: Option<Vec<CharacterProfileAttributesCharacterPresentationFeature>>,
    pub ragrpresentationfeatures: Option<Vec<RasterGrProfileAttributesRaGrPresentationFeature>>,
    pub geogrpresentationfeatures: Option<Vec<GeoGrProfileAttributesGeoGrPresentationFeature>>,
    pub charactercodingattributes: Option<Vec<CharacterProfileAttributesCharacterCodingAttribute>>,
    pub ragrcodingattributes: Option<Vec<RasterGrProfileAttributesRaGrCodingAttribute>>,
    pub geogrcodingattributes: Option<Vec<GeoGrProfileAttributesGeoGrCodingAttribute>>,
    pub extnonbasicpresfeatures: Option<Vec<ASN1Node>>,
    pub extnonbasiccodingattributes: Option<Vec<ASN1Node>>,
}

impl DocumentProfileDescriptorNonBasicDocCharacteristics {
    pub fn new(profilecharactersets: Option<ASN1OctetString>, commentscharactersets: Option<ASN1OctetString>, alternativereprcharsets: Option<ASN1OctetString>, pagedimensions: Option<Vec<LayoutDescriptorsDimensionPair>>, mediumtypes: Option<Vec<LayoutDescriptorsMediumType>>, layoutpaths: Option<Vec<LayoutDescriptorsOneOfFourAngles>>, transparencies: Option<Vec<LayoutDescriptorsTransparency>>, protections: Option<Vec<LogicalDescriptorsProtection>>, blockalignments: Option<Vec<StyleDescriptorsBlockAlignment>>, fillorders: Option<Vec<StyleDescriptorsFillOrder>>, colours: Option<Vec<LayoutDescriptorsColour>>, coloursoflayoutobject: Option<Vec<ColourAttributesColourExpression>>, objectcolourtables: Option<Vec<ColourAttributesColourTable>>, contentbackgroundcolours: Option<Vec<LayoutDescriptorsContentBackgroundColour>>, contentforegroundcolours: Option<Vec<LayoutDescriptorsContentForegroundColour>>, contentcolourtables: Option<Vec<ColourAttributesColourTable>>, borders: Option<Vec<LayoutDescriptorsBorder>>, pagepositions: Option<Vec<LayoutDescriptorsMeasurePair>>, typesofcoding: Option<Vec<TextUnitsTypeOfCoding>>, characterpresentationfeatures: Option<Vec<CharacterProfileAttributesCharacterPresentationFeature>>, ragrpresentationfeatures: Option<Vec<RasterGrProfileAttributesRaGrPresentationFeature>>, geogrpresentationfeatures: Option<Vec<GeoGrProfileAttributesGeoGrPresentationFeature>>, charactercodingattributes: Option<Vec<CharacterProfileAttributesCharacterCodingAttribute>>, ragrcodingattributes: Option<Vec<RasterGrProfileAttributesRaGrCodingAttribute>>, geogrcodingattributes: Option<Vec<GeoGrProfileAttributesGeoGrCodingAttribute>>, extnonbasicpresfeatures: Option<Vec<ASN1Node>>, extnonbasiccodingattributes: Option<Vec<ASN1Node>>) -> Self {
        Self {
            profilecharactersets,
            commentscharactersets,
            alternativereprcharsets,
            pagedimensions,
            mediumtypes,
            layoutpaths,
            transparencies,
            protections,
            blockalignments,
            fillorders,
            colours,
            coloursoflayoutobject,
            objectcolourtables,
            contentbackgroundcolours,
            contentforegroundcolours,
            contentcolourtables,
            borders,
            pagepositions,
            typesofcoding,
            characterpresentationfeatures,
            ragrpresentationfeatures,
            geogrpresentationfeatures,
            charactercodingattributes,
            ragrcodingattributes,
            geogrcodingattributes,
            extnonbasicpresfeatures,
            extnonbasiccodingattributes,
        }
    }
}

impl DERParseable for DocumentProfileDescriptorNonBasicDocCharacteristics {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;
            let profilecharactersets: Option<ASN1OctetString> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1OctetString::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let commentscharactersets: Option<ASN1OctetString> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1OctetString::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let alternativereprcharsets: Option<ASN1OctetString> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1OctetString::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let pagedimensions: Option<Vec<LayoutDescriptorsDimensionPair>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsDimensionPair::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let mediumtypes: Option<Vec<LayoutDescriptorsMediumType>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsMediumType::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let layoutpaths: Option<Vec<LayoutDescriptorsOneOfFourAngles>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsOneOfFourAngles::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let transparencies: Option<Vec<LayoutDescriptorsTransparency>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsTransparency::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let protections: Option<Vec<LogicalDescriptorsProtection>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LogicalDescriptorsProtection::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let blockalignments: Option<Vec<StyleDescriptorsBlockAlignment>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| StyleDescriptorsBlockAlignment::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let fillorders: Option<Vec<StyleDescriptorsFillOrder>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| StyleDescriptorsFillOrder::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let colours: Option<Vec<LayoutDescriptorsColour>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsColour::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let coloursoflayoutobject: Option<Vec<ColourAttributesColourExpression>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| ColourAttributesColourExpression::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let objectcolourtables: Option<Vec<ColourAttributesColourTable>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| ColourAttributesColourTable::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let contentbackgroundcolours: Option<Vec<LayoutDescriptorsContentBackgroundColour>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsContentBackgroundColour::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let contentforegroundcolours: Option<Vec<LayoutDescriptorsContentForegroundColour>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsContentForegroundColour::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let contentcolourtables: Option<Vec<ColourAttributesColourTable>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| ColourAttributesColourTable::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let borders: Option<Vec<LayoutDescriptorsBorder>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsBorder::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let pagepositions: Option<Vec<LayoutDescriptorsMeasurePair>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| LayoutDescriptorsMeasurePair::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let typesofcoding: Option<Vec<TextUnitsTypeOfCoding>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| TextUnitsTypeOfCoding::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let characterpresentationfeatures: Option<Vec<CharacterProfileAttributesCharacterPresentationFeature>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| CharacterProfileAttributesCharacterPresentationFeature::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let ragrpresentationfeatures: Option<Vec<RasterGrProfileAttributesRaGrPresentationFeature>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| RasterGrProfileAttributesRaGrPresentationFeature::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let geogrpresentationfeatures: Option<Vec<GeoGrProfileAttributesGeoGrPresentationFeature>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| GeoGrProfileAttributesGeoGrPresentationFeature::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let charactercodingattributes: Option<Vec<CharacterProfileAttributesCharacterCodingAttribute>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| CharacterProfileAttributesCharacterCodingAttribute::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let ragrcodingattributes: Option<Vec<RasterGrProfileAttributesRaGrCodingAttribute>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| RasterGrProfileAttributesRaGrCodingAttribute::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let geogrcodingattributes: Option<Vec<GeoGrProfileAttributesGeoGrCodingAttribute>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| GeoGrProfileAttributesGeoGrCodingAttribute::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let extnonbasicpresfeatures: Option<Vec<ASN1Node>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); Some(collection.clone().into_iter().collect::<Vec<ASN1Node>>()) } else { None } } else { None };
            let extnonbasiccodingattributes: Option<Vec<ASN1Node>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); Some(collection.clone().into_iter().collect::<Vec<ASN1Node>>()) } else { None } } else { None };
            Ok(Self {
                profilecharactersets: profilecharactersets,
                commentscharactersets: commentscharactersets,
                alternativereprcharsets: alternativereprcharsets,
                pagedimensions: pagedimensions,
                mediumtypes: mediumtypes,
                layoutpaths: layoutpaths,
                transparencies: transparencies,
                protections: protections,
                blockalignments: blockalignments,
                fillorders: fillorders,
                colours: colours,
                coloursoflayoutobject: coloursoflayoutobject,
                objectcolourtables: objectcolourtables,
                contentbackgroundcolours: contentbackgroundcolours,
                contentforegroundcolours: contentforegroundcolours,
                contentcolourtables: contentcolourtables,
                borders: borders,
                pagepositions: pagepositions,
                typesofcoding: typesofcoding,
                characterpresentationfeatures: characterpresentationfeatures,
                ragrpresentationfeatures: ragrpresentationfeatures,
                geogrpresentationfeatures: geogrpresentationfeatures,
                charactercodingattributes: charactercodingattributes,
                ragrcodingattributes: ragrcodingattributes,
                geogrcodingattributes: geogrcodingattributes,
                extnonbasicpresfeatures: extnonbasicpresfeatures,
                extnonbasiccodingattributes: extnonbasiccodingattributes,
            })

        })
    }
}

impl DERSerializable for DocumentProfileDescriptorNonBasicDocCharacteristics {
    fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
        Err(ASN1Error::new(
            rust_asn1::errors::ErrorCode::UnsupportedFieldLength,
            "Serialization is not implemented by the generator yet.".to_string(),
            file!().to_string(),
            line!(),
        ))
    }
}
