// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct GeoGrProfileAttributesGeoGrContentDefaults {
    pub linerendition: Option<crate::GeoGrPresentationAttributesLineRendition>,
    pub markerrendition: Option<crate::GeoGrPresentationAttributesMarkerRendition>,
    pub textrendition: Option<crate::GeoGrPresentationAttributesTextRendition>,
    pub filledarearendition: Option<crate::GeoGrPresentationAttributesFilledAreaRendition>,
    pub edgerendition: Option<crate::GeoGrPresentationAttributesEdgeRendition>,
    pub colourrepresentations: Option<crate::GeoGrPresentationAttributesColourRepresentations>,
    pub transparencyspecification: Option<crate::GeoGrPresentationAttributesTransparencySpecification>,
    pub transformationspecification: Option<crate::GeoGrPresentationAttributesTransformationSpecification>,
    pub regionofinterestspecification: Option<crate::GeoGrPresentationAttributesRegionOfInterestSpecification>,
    pub pictureorientation: Option<crate::GeoGrPresentationAttributesPictureOrientation>,
    pub picturedimensions: Option<crate::GeoGrPresentationAttributesPictureDimensions>,
}

impl GeoGrProfileAttributesGeoGrContentDefaults {
    pub fn new(linerendition: Option<crate::GeoGrPresentationAttributesLineRendition>, markerrendition: Option<crate::GeoGrPresentationAttributesMarkerRendition>, textrendition: Option<crate::GeoGrPresentationAttributesTextRendition>, filledarearendition: Option<crate::GeoGrPresentationAttributesFilledAreaRendition>, edgerendition: Option<crate::GeoGrPresentationAttributesEdgeRendition>, colourrepresentations: Option<crate::GeoGrPresentationAttributesColourRepresentations>, transparencyspecification: Option<crate::GeoGrPresentationAttributesTransparencySpecification>, transformationspecification: Option<crate::GeoGrPresentationAttributesTransformationSpecification>, regionofinterestspecification: Option<crate::GeoGrPresentationAttributesRegionOfInterestSpecification>, pictureorientation: Option<crate::GeoGrPresentationAttributesPictureOrientation>, picturedimensions: Option<crate::GeoGrPresentationAttributesPictureDimensions>) -> Self {
        Self {
            linerendition,
            markerrendition,
            textrendition,
            filledarearendition,
            edgerendition,
            colourrepresentations,
            transparencyspecification,
            transformationspecification,
            regionofinterestspecification,
            pictureorientation,
            picturedimensions,
        }
    }
}

impl DERParseable for GeoGrProfileAttributesGeoGrContentDefaults {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;
            let linerendition: Option<crate::GeoGrPresentationAttributesLineRendition> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesLineRendition::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let markerrendition: Option<crate::GeoGrPresentationAttributesMarkerRendition> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesMarkerRendition::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textrendition: Option<crate::GeoGrPresentationAttributesTextRendition> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTextRendition::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let filledarearendition: Option<crate::GeoGrPresentationAttributesFilledAreaRendition> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesFilledAreaRendition::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let edgerendition: Option<crate::GeoGrPresentationAttributesEdgeRendition> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesEdgeRendition::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let colourrepresentations: Option<crate::GeoGrPresentationAttributesColourRepresentations> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesColourRepresentations::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let transparencyspecification: Option<crate::GeoGrPresentationAttributesTransparencySpecification> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTransparencySpecification::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let transformationspecification: Option<crate::GeoGrPresentationAttributesTransformationSpecification> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTransformationSpecification::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let regionofinterestspecification: Option<crate::GeoGrPresentationAttributesRegionOfInterestSpecification> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesRegionOfInterestSpecification::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let pictureorientation: Option<crate::GeoGrPresentationAttributesPictureOrientation> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesPictureOrientation::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let picturedimensions: Option<crate::GeoGrPresentationAttributesPictureDimensions> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesPictureDimensions::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            Ok(Self {
                linerendition: linerendition,
                markerrendition: markerrendition,
                textrendition: textrendition,
                filledarearendition: filledarearendition,
                edgerendition: edgerendition,
                colourrepresentations: colourrepresentations,
                transparencyspecification: transparencyspecification,
                transformationspecification: transformationspecification,
                regionofinterestspecification: regionofinterestspecification,
                pictureorientation: pictureorientation,
                picturedimensions: picturedimensions,
            })

        })
    }
}

impl DERSerializable for GeoGrProfileAttributesGeoGrContentDefaults {
    fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
        Err(ASN1Error::new(
            rust_asn1::errors::ErrorCode::UnsupportedFieldLength,
            "Serialization is not implemented by the generator yet.".to_string(),
            file!().to_string(),
            line!(),
        ))
    }
}
