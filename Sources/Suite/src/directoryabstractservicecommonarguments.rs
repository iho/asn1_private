// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct DirectoryAbstractServiceCommonArguments {
    pub service_controls: crate::DirectoryAbstractServiceServiceControls,
    pub security_parameters: Option<crate::DirectoryAbstractServiceSecurityParameters>,
    pub requestor: Option<crate::InformationFrameworkDistinguishedName>,
    pub operation_progress: crate::DirectoryAbstractServiceOperationProgress,
    pub aliased_rd_ns: Option<ASN1Integer>,
    pub critical_extensions: Option<ASN1BitString>,
    pub reference_type: Option<crate::DirectoryAbstractServiceReferenceType>,
    pub entry_only: ASN1Boolean,
    pub name_resolve_on_maste: ASN1Boolean,
    pub operation_contexts: Option<crate::DirectoryAbstractServiceContextSelection>,
    pub family_grouping: crate::DirectoryAbstractServiceFamilyGrouping,
}

impl DirectoryAbstractServiceCommonArguments {
    pub fn new(service_controls: crate::DirectoryAbstractServiceServiceControls, security_parameters: Option<crate::DirectoryAbstractServiceSecurityParameters>, requestor: Option<crate::InformationFrameworkDistinguishedName>, operation_progress: crate::DirectoryAbstractServiceOperationProgress, aliased_rd_ns: Option<ASN1Integer>, critical_extensions: Option<ASN1BitString>, reference_type: Option<crate::DirectoryAbstractServiceReferenceType>, entry_only: ASN1Boolean, name_resolve_on_maste: ASN1Boolean, operation_contexts: Option<crate::DirectoryAbstractServiceContextSelection>, family_grouping: crate::DirectoryAbstractServiceFamilyGrouping) -> Self {
        Self {
            service_controls,
            security_parameters,
            requestor,
            operation_progress,
            aliased_rd_ns,
            critical_extensions,
            reference_type,
            entry_only,
            name_resolve_on_maste,
            operation_contexts,
            family_grouping,
        }
    }
}

impl DERParseable for DirectoryAbstractServiceCommonArguments {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;
            let service_controls = crate::DirectoryAbstractServiceServiceControls::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let security_parameters: Option<crate::DirectoryAbstractServiceSecurityParameters> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::DirectoryAbstractServiceSecurityParameters::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let requestor: Option<crate::InformationFrameworkDistinguishedName> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::InformationFrameworkDistinguishedName::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let operation_progress = crate::DirectoryAbstractServiceOperationProgress::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let aliased_rd_ns: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let critical_extensions: Option<ASN1BitString> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1BitString::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let reference_type: Option<crate::DirectoryAbstractServiceReferenceType> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::DirectoryAbstractServiceReferenceType::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let entry_only = ASN1Boolean::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let name_resolve_on_maste = ASN1Boolean::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let operation_contexts: Option<crate::DirectoryAbstractServiceContextSelection> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::DirectoryAbstractServiceContextSelection::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let family_grouping = crate::DirectoryAbstractServiceFamilyGrouping::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            Ok(Self {
                service_controls: service_controls,
                security_parameters: security_parameters,
                requestor: requestor,
                operation_progress: operation_progress,
                aliased_rd_ns: aliased_rd_ns,
                critical_extensions: critical_extensions,
                reference_type: reference_type,
                entry_only: entry_only,
                name_resolve_on_maste: name_resolve_on_maste,
                operation_contexts: operation_contexts,
                family_grouping: family_grouping,
            })

        })
    }
}

impl DERSerializable for DirectoryAbstractServiceCommonArguments {
    fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
        Err(ASN1Error::new(
            rust_asn1::errors::ErrorCode::UnsupportedFieldLength,
            "Serialization is not implemented by the generator yet.".to_string(),
            file!().to_string(),
            line!(),
        ))
    }
}
