// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct GeoGrPresentationAttributesTextRendition {
    pub fontlist: Option<Vec<ASN1UTF8String>>,
    pub charactersetlist: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterSetListSequence>,
    pub charactercodingannouncer: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterCodingAnnouncerEnum>,
    pub textbundleindex: Option<ASN1Integer>,
    pub textfontindex: Option<ASN1Integer>,
    pub textprecision: Option<crate::GeoGrPresentationAttributesTextRenditionTextPrecisionEnum>,
    pub characterexpansionfactor: Option<ASN1Real>,
    pub characterspacing: Option<ASN1Real>,
    pub textcolour: Option<crate::GeoGrPresentationAttributesColour>,
    pub characterheight: Option<crate::GeoGrPresentationAttributesVDCValue>,
    pub characterorientation: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterOrientationSequence>,
    pub textpath: Option<crate::GeoGrPresentationAttributesTextRenditionTextPathEnum>,
    pub textalignment: Option<crate::GeoGrPresentationAttributesTextRenditionTextAlignmentSequence>,
    pub charactersetindex: Option<ASN1Integer>,
    pub alternatecharactersetindex: Option<ASN1Integer>,
    pub textaspectsourceflags: Option<crate::GeoGrPresentationAttributesTextRenditionTextAspectSourceFlagsSequence>,
    pub textbundlespecifications: Option<Vec<ASN1Node>>,
}

impl GeoGrPresentationAttributesTextRendition {
    pub fn new(fontlist: Option<Vec<ASN1UTF8String>>, charactersetlist: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterSetListSequence>, charactercodingannouncer: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterCodingAnnouncerEnum>, textbundleindex: Option<ASN1Integer>, textfontindex: Option<ASN1Integer>, textprecision: Option<crate::GeoGrPresentationAttributesTextRenditionTextPrecisionEnum>, characterexpansionfactor: Option<ASN1Real>, characterspacing: Option<ASN1Real>, textcolour: Option<crate::GeoGrPresentationAttributesColour>, characterheight: Option<crate::GeoGrPresentationAttributesVDCValue>, characterorientation: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterOrientationSequence>, textpath: Option<crate::GeoGrPresentationAttributesTextRenditionTextPathEnum>, textalignment: Option<crate::GeoGrPresentationAttributesTextRenditionTextAlignmentSequence>, charactersetindex: Option<ASN1Integer>, alternatecharactersetindex: Option<ASN1Integer>, textaspectsourceflags: Option<crate::GeoGrPresentationAttributesTextRenditionTextAspectSourceFlagsSequence>, textbundlespecifications: Option<Vec<ASN1Node>>) -> Self {
        Self {
            fontlist,
            charactersetlist,
            charactercodingannouncer,
            textbundleindex,
            textfontindex,
            textprecision,
            characterexpansionfactor,
            characterspacing,
            textcolour,
            characterheight,
            characterorientation,
            textpath,
            textalignment,
            charactersetindex,
            alternatecharactersetindex,
            textaspectsourceflags,
            textbundlespecifications,
        }
    }
}

impl DERParseable for GeoGrPresentationAttributesTextRendition {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;
            let fontlist: Option<Vec<ASN1UTF8String>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| ASN1UTF8String::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let charactersetlist: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterSetListSequence> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTextRenditionCharacterSetListSequence::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let charactercodingannouncer: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterCodingAnnouncerEnum> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTextRenditionCharacterCodingAnnouncerEnum::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textbundleindex: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textfontindex: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textprecision: Option<crate::GeoGrPresentationAttributesTextRenditionTextPrecisionEnum> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTextRenditionTextPrecisionEnum::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let characterexpansionfactor: Option<ASN1Real> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Real::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let characterspacing: Option<ASN1Real> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Real::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textcolour: Option<crate::GeoGrPresentationAttributesColour> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesColour::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let characterheight: Option<crate::GeoGrPresentationAttributesVDCValue> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesVDCValue::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let characterorientation: Option<crate::GeoGrPresentationAttributesTextRenditionCharacterOrientationSequence> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTextRenditionCharacterOrientationSequence::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textpath: Option<crate::GeoGrPresentationAttributesTextRenditionTextPathEnum> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTextRenditionTextPathEnum::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textalignment: Option<crate::GeoGrPresentationAttributesTextRenditionTextAlignmentSequence> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTextRenditionTextAlignmentSequence::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let charactersetindex: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let alternatecharactersetindex: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textaspectsourceflags: Option<crate::GeoGrPresentationAttributesTextRenditionTextAspectSourceFlagsSequence> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::GeoGrPresentationAttributesTextRenditionTextAspectSourceFlagsSequence::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let textbundlespecifications: Option<Vec<ASN1Node>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); Some(collection.clone().into_iter().collect::<Vec<ASN1Node>>()) } else { None } } else { None };
            Ok(Self {
                fontlist: fontlist,
                charactersetlist: charactersetlist,
                charactercodingannouncer: charactercodingannouncer,
                textbundleindex: textbundleindex,
                textfontindex: textfontindex,
                textprecision: textprecision,
                characterexpansionfactor: characterexpansionfactor,
                characterspacing: characterspacing,
                textcolour: textcolour,
                characterheight: characterheight,
                characterorientation: characterorientation,
                textpath: textpath,
                textalignment: textalignment,
                charactersetindex: charactersetindex,
                alternatecharactersetindex: alternatecharactersetindex,
                textaspectsourceflags: textaspectsourceflags,
                textbundlespecifications: textbundlespecifications,
            })

        })
    }
}

impl DERSerializable for GeoGrPresentationAttributesTextRendition {
    fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
        Err(ASN1Error::new(
            rust_asn1::errors::ErrorCode::UnsupportedFieldLength,
            "Serialization is not implemented by the generator yet.".to_string(),
            file!().to_string(),
            line!(),
        ))
    }
}
