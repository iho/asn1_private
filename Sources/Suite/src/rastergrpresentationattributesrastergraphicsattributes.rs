// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct RasterGrPresentationAttributesRasterGraphicsAttributes {
    pub pelpath: Option<crate::RasterGrPresentationAttributesOneOfFourAngles>,
    pub lineprogression: Option<crate::RasterGrPresentationAttributesOneOfTwoAngles>,
    pub peltransmissiondensity: Option<crate::RasterGrPresentationAttributesPelTransmissionDensity>,
    pub initialoffset: Option<crate::RasterGrPresentationAttributesMeasurePair>,
    pub clipping: Option<crate::RasterGrPresentationAttributesClipping>,
    pub pelspacing: Option<crate::RasterGrPresentationAttributesPelSpacing>,
    pub spacingratio: Option<crate::RasterGrPresentationAttributesSpacingRatio>,
    pub imagedimensions: Option<crate::RasterGrPresentationAttributesImageDimensions>,
}

impl RasterGrPresentationAttributesRasterGraphicsAttributes {
    pub fn new(pelpath: Option<crate::RasterGrPresentationAttributesOneOfFourAngles>, lineprogression: Option<crate::RasterGrPresentationAttributesOneOfTwoAngles>, peltransmissiondensity: Option<crate::RasterGrPresentationAttributesPelTransmissionDensity>, initialoffset: Option<crate::RasterGrPresentationAttributesMeasurePair>, clipping: Option<crate::RasterGrPresentationAttributesClipping>, pelspacing: Option<crate::RasterGrPresentationAttributesPelSpacing>, spacingratio: Option<crate::RasterGrPresentationAttributesSpacingRatio>, imagedimensions: Option<crate::RasterGrPresentationAttributesImageDimensions>) -> Self {
        Self {
            pelpath,
            lineprogression,
            peltransmissiondensity,
            initialoffset,
            clipping,
            pelspacing,
            spacingratio,
            imagedimensions,
        }
    }
}

impl DERParseable for RasterGrPresentationAttributesRasterGraphicsAttributes {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;
            let pelpath: Option<crate::RasterGrPresentationAttributesOneOfFourAngles> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::RasterGrPresentationAttributesOneOfFourAngles::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let lineprogression: Option<crate::RasterGrPresentationAttributesOneOfTwoAngles> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::RasterGrPresentationAttributesOneOfTwoAngles::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let peltransmissiondensity: Option<crate::RasterGrPresentationAttributesPelTransmissionDensity> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::RasterGrPresentationAttributesPelTransmissionDensity::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let initialoffset: Option<crate::RasterGrPresentationAttributesMeasurePair> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::RasterGrPresentationAttributesMeasurePair::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let clipping: Option<crate::RasterGrPresentationAttributesClipping> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::RasterGrPresentationAttributesClipping::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let pelspacing: Option<crate::RasterGrPresentationAttributesPelSpacing> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::RasterGrPresentationAttributesPelSpacing::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let spacingratio: Option<crate::RasterGrPresentationAttributesSpacingRatio> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::RasterGrPresentationAttributesSpacingRatio::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let imagedimensions: Option<crate::RasterGrPresentationAttributesImageDimensions> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::RasterGrPresentationAttributesImageDimensions::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            Ok(Self {
                pelpath: pelpath,
                lineprogression: lineprogression,
                peltransmissiondensity: peltransmissiondensity,
                initialoffset: initialoffset,
                clipping: clipping,
                pelspacing: pelspacing,
                spacingratio: spacingratio,
                imagedimensions: imagedimensions,
            })

        })
    }
}

impl DERSerializable for RasterGrPresentationAttributesRasterGraphicsAttributes {
    fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
        Err(ASN1Error::new(
            rust_asn1::errors::ErrorCode::UnsupportedFieldLength,
            "Serialization is not implemented by the generator yet.".to_string(),
            file!().to_string(),
            line!(),
        ))
    }
}
