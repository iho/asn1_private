// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct CharacterPresentationAttributesCharacterAttributes {
    pub characterpath: Option<crate::CharacterPresentationAttributesOneOfFourAngles>,
    pub lineprogression: Option<crate::CharacterPresentationAttributesOneOfTwoAngles>,
    pub characterorientation: Option<crate::CharacterPresentationAttributesOneOfFourAngles>,
    pub initialoffset: Option<crate::CharacterPresentationAttributesMeasurePair>,
    pub characterspacing: Option<ASN1Integer>,
    pub linespacing: Option<ASN1Integer>,
    pub alignment: Option<crate::CharacterPresentationAttributesAlignment>,
    pub linelayouttable: Option<crate::CharacterPresentationAttributesLayoutTable>,
    pub graphicrendition: Option<crate::CharacterPresentationAttributesGraphicRendition>,
    pub formattingindicator: Option<crate::CharacterPresentationAttributesFormattingIndicator>,
    pub characterfonts: Option<crate::CharacterPresentationAttributesCharacterFonts>,
    pub graphiccharsubrepertoire: Option<ASN1Integer>,
    pub itemization: Option<crate::CharacterPresentationAttributesItemization>,
    pub widowsize: Option<ASN1Integer>,
    pub orphansize: Option<ASN1Integer>,
    pub graphiccharactersets: Option<ASN1OctetString>,
    pub indentation: Option<ASN1Integer>,
    pub kerningoffset: Option<crate::CharacterPresentationAttributesKerningOffset>,
    pub proportionallinespacing: Option<crate::CharacterPresentationAttributesProportionalLineSpacing>,
    pub pairwisekerning: Option<crate::CharacterPresentationAttributesPairwiseKerning>,
    pub firstlineoffset: Option<ASN1Integer>,
    pub codeextensionannouncers: Option<ASN1OctetString>,
}

impl CharacterPresentationAttributesCharacterAttributes {
    pub fn new(characterpath: Option<crate::CharacterPresentationAttributesOneOfFourAngles>, lineprogression: Option<crate::CharacterPresentationAttributesOneOfTwoAngles>, characterorientation: Option<crate::CharacterPresentationAttributesOneOfFourAngles>, initialoffset: Option<crate::CharacterPresentationAttributesMeasurePair>, characterspacing: Option<ASN1Integer>, linespacing: Option<ASN1Integer>, alignment: Option<crate::CharacterPresentationAttributesAlignment>, linelayouttable: Option<crate::CharacterPresentationAttributesLayoutTable>, graphicrendition: Option<crate::CharacterPresentationAttributesGraphicRendition>, formattingindicator: Option<crate::CharacterPresentationAttributesFormattingIndicator>, characterfonts: Option<crate::CharacterPresentationAttributesCharacterFonts>, graphiccharsubrepertoire: Option<ASN1Integer>, itemization: Option<crate::CharacterPresentationAttributesItemization>, widowsize: Option<ASN1Integer>, orphansize: Option<ASN1Integer>, graphiccharactersets: Option<ASN1OctetString>, indentation: Option<ASN1Integer>, kerningoffset: Option<crate::CharacterPresentationAttributesKerningOffset>, proportionallinespacing: Option<crate::CharacterPresentationAttributesProportionalLineSpacing>, pairwisekerning: Option<crate::CharacterPresentationAttributesPairwiseKerning>, firstlineoffset: Option<ASN1Integer>, codeextensionannouncers: Option<ASN1OctetString>) -> Self {
        Self {
            characterpath,
            lineprogression,
            characterorientation,
            initialoffset,
            characterspacing,
            linespacing,
            alignment,
            linelayouttable,
            graphicrendition,
            formattingindicator,
            characterfonts,
            graphiccharsubrepertoire,
            itemization,
            widowsize,
            orphansize,
            graphiccharactersets,
            indentation,
            kerningoffset,
            proportionallinespacing,
            pairwisekerning,
            firstlineoffset,
            codeextensionannouncers,
        }
    }
}

impl DERParseable for CharacterPresentationAttributesCharacterAttributes {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;
            let characterpath: Option<crate::CharacterPresentationAttributesOneOfFourAngles> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesOneOfFourAngles::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let lineprogression: Option<crate::CharacterPresentationAttributesOneOfTwoAngles> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesOneOfTwoAngles::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let characterorientation: Option<crate::CharacterPresentationAttributesOneOfFourAngles> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesOneOfFourAngles::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let initialoffset: Option<crate::CharacterPresentationAttributesMeasurePair> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesMeasurePair::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let characterspacing: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let linespacing: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let alignment: Option<crate::CharacterPresentationAttributesAlignment> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesAlignment::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let linelayouttable: Option<crate::CharacterPresentationAttributesLayoutTable> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesLayoutTable::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let graphicrendition: Option<crate::CharacterPresentationAttributesGraphicRendition> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesGraphicRendition::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let formattingindicator: Option<crate::CharacterPresentationAttributesFormattingIndicator> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesFormattingIndicator::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let characterfonts: Option<crate::CharacterPresentationAttributesCharacterFonts> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesCharacterFonts::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let graphiccharsubrepertoire: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let itemization: Option<crate::CharacterPresentationAttributesItemization> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesItemization::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let widowsize: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let orphansize: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let graphiccharactersets: Option<ASN1OctetString> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1OctetString::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let indentation: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let kerningoffset: Option<crate::CharacterPresentationAttributesKerningOffset> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesKerningOffset::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let proportionallinespacing: Option<crate::CharacterPresentationAttributesProportionalLineSpacing> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesProportionalLineSpacing::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let pairwisekerning: Option<crate::CharacterPresentationAttributesPairwiseKerning> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match crate::CharacterPresentationAttributesPairwiseKerning::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let firstlineoffset: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let codeextensionannouncers: Option<ASN1OctetString> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1OctetString::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            Ok(Self {
                characterpath: characterpath,
                lineprogression: lineprogression,
                characterorientation: characterorientation,
                initialoffset: initialoffset,
                characterspacing: characterspacing,
                linespacing: linespacing,
                alignment: alignment,
                linelayouttable: linelayouttable,
                graphicrendition: graphicrendition,
                formattingindicator: formattingindicator,
                characterfonts: characterfonts,
                graphiccharsubrepertoire: graphiccharsubrepertoire,
                itemization: itemization,
                widowsize: widowsize,
                orphansize: orphansize,
                graphiccharactersets: graphiccharactersets,
                indentation: indentation,
                kerningoffset: kerningoffset,
                proportionallinespacing: proportionallinespacing,
                pairwisekerning: pairwisekerning,
                firstlineoffset: firstlineoffset,
                codeextensionannouncers: codeextensionannouncers,
            })

        })
    }
}

impl DERSerializable for CharacterPresentationAttributesCharacterAttributes {
    fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
        Err(ASN1Error::new(
            rust_asn1::errors::ErrorCode::UnsupportedFieldLength,
            "Serialization is not implemented by the generator yet.".to_string(),
            file!().to_string(),
            line!(),
        ))
    }
}
