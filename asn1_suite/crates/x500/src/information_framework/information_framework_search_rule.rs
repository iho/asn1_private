// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct InformationFrameworkSearchRule {
    pub service_type: Option<ASN1ObjectIdentifier>,
    pub user_class: Option<ASN1Integer>,
    pub input_attribute_types: Option<Vec<InformationFrameworkRequestAttribute>>,
    pub attribute_combination: InformationFrameworkAttributeCombination,
    pub output_attribute_types: Option<Vec<InformationFrameworkResultAttribute>>,
    pub default_controls: Option<InformationFrameworkControlOptions>,
    pub mandatory_controls: Option<InformationFrameworkControlOptions>,
    pub search_rule_controls: Option<InformationFrameworkControlOptions>,
    pub family_grouping: Option<DirectoryAbstractServiceFamilyGrouping>,
    pub family_return: Option<DirectoryAbstractServiceFamilyReturn>,
    pub relaxation: Option<InformationFrameworkRelaxationPolicy>,
    pub additional_control: Option<Vec<InformationFrameworkAttributeType>>,
    pub allowed_subset: InformationFrameworkAllowedSubset,
    pub imposed_subset: Option<InformationFrameworkImposedSubset>,
    pub entry_limit: Option<InformationFrameworkEntryLimit>,
}

impl InformationFrameworkSearchRule {
    pub fn new(service_type: Option<ASN1ObjectIdentifier>, user_class: Option<ASN1Integer>, input_attribute_types: Option<Vec<InformationFrameworkRequestAttribute>>, attribute_combination: InformationFrameworkAttributeCombination, output_attribute_types: Option<Vec<InformationFrameworkResultAttribute>>, default_controls: Option<InformationFrameworkControlOptions>, mandatory_controls: Option<InformationFrameworkControlOptions>, search_rule_controls: Option<InformationFrameworkControlOptions>, family_grouping: Option<DirectoryAbstractServiceFamilyGrouping>, family_return: Option<DirectoryAbstractServiceFamilyReturn>, relaxation: Option<InformationFrameworkRelaxationPolicy>, additional_control: Option<Vec<InformationFrameworkAttributeType>>, allowed_subset: InformationFrameworkAllowedSubset, imposed_subset: Option<InformationFrameworkImposedSubset>, entry_limit: Option<InformationFrameworkEntryLimit>) -> Self {
        Self {
            service_type,
            user_class,
            input_attribute_types,
            attribute_combination,
            output_attribute_types,
            default_controls,
            mandatory_controls,
            search_rule_controls,
            family_grouping,
            family_return,
            relaxation,
            additional_control,
            allowed_subset,
            imposed_subset,
            entry_limit,
        }
    }
}

impl DERParseable for InformationFrameworkSearchRule {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;

            let service_type: Option<ASN1ObjectIdentifier> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1ObjectIdentifier::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let user_class: Option<ASN1Integer> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let input_attribute_types: Option<Vec<InformationFrameworkRequestAttribute>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| InformationFrameworkRequestAttribute::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let attribute_combination = InformationFrameworkAttributeCombination::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let output_attribute_types: Option<Vec<InformationFrameworkResultAttribute>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| InformationFrameworkResultAttribute::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let default_controls: Option<InformationFrameworkControlOptions> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match InformationFrameworkControlOptions::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let mandatory_controls: Option<InformationFrameworkControlOptions> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match InformationFrameworkControlOptions::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let search_rule_controls: Option<InformationFrameworkControlOptions> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match InformationFrameworkControlOptions::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let family_grouping: Option<DirectoryAbstractServiceFamilyGrouping> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match DirectoryAbstractServiceFamilyGrouping::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let family_return: Option<DirectoryAbstractServiceFamilyReturn> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match DirectoryAbstractServiceFamilyReturn::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let relaxation: Option<InformationFrameworkRelaxationPolicy> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match InformationFrameworkRelaxationPolicy::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let additional_control: Option<Vec<InformationFrameworkAttributeType>> = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| InformationFrameworkAttributeType::from_der_node(child)).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };
            let allowed_subset = InformationFrameworkAllowedSubset::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let imposed_subset: Option<InformationFrameworkImposedSubset> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match InformationFrameworkImposedSubset::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let entry_limit: Option<InformationFrameworkEntryLimit> = if let Some(node) = nodes.peek().map(|n| n.clone()) { match InformationFrameworkEntryLimit::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            Ok(Self {

                service_type: service_type,
                user_class: user_class,
                input_attribute_types: input_attribute_types,
                attribute_combination: attribute_combination,
                output_attribute_types: output_attribute_types,
                default_controls: default_controls,
                mandatory_controls: mandatory_controls,
                search_rule_controls: search_rule_controls,
                family_grouping: family_grouping,
                family_return: family_return,
                relaxation: relaxation,
                additional_control: additional_control,
                allowed_subset: allowed_subset,
                imposed_subset: imposed_subset,
                entry_limit: entry_limit,
            })

        })
    }
}

impl DERSerializable for InformationFrameworkSearchRule {
    fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
        Err(ASN1Error::new(
            rust_asn1::errors::ErrorCode::UnsupportedFieldLength,
            "Serialization is not implemented by the generator yet.".to_string(),
            file!().to_string(),
            line!(),
        ))
    }
}
