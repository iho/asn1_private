defmodule ASN1.Emitters.Rust do
  @behaviour ASN1.Emitter

  def language(), do: "Rust"
  def extension(), do: ".rs"

  def finalize(output_dir) do
      # Generate mod.rs at the root of output_dir
      # List all .rs files in the directory
      case :file.list_dir(output_dir) do
          {:ok, files} ->
              modules = Enum.filter(files, fn f ->
                  s = to_string(f)
                  String.ends_with?(s, ".rs") and s != "mod.rs"
              end)
              |> Enum.map(fn f ->
                  name = to_string(f) |> String.replace(".rs", "")
                  "pub mod #{name};"
              end)
              |> Enum.join("\n")

              mod_file_path = Path.join(output_dir, "mod.rs")
              File.write!(mod_file_path, modules <> "\n")
              :io.format("Generated mod.rs at ~s~n", [mod_file_path])
          {:error, reason} ->
              :io.format("Failed to list files for mod.rs generation: ~p~n", [reason])
      end
  end

  def emit_imprint(), do: "// Generated by ASN1.ERP.UNO Compiler"

  def substitute_type("INTEGER"),           do: "i64"
  def substitute_type("BOOLEAN"),           do: "bool"
  def substitute_type("OCTET STRING"),      do: "Vec<u8>"
  def substitute_type("BIT STRING"),        do: "rust_asn1::BitString"
  def substitute_type("IA5String"),         do: "String"
  def substitute_type("UTF8String"),        do: "String"
  def substitute_type("PrintableString"),   do: "String"
  def substitute_type("NumericString"),     do: "String"
  def substitute_type("VisibleString"),     do: "String"
  def substitute_type("GeneralString"),     do: "String"
  def substitute_type("GeneralizedTime"),   do: "String"
  def substitute_type("UTCTime"),           do: "String"
  def substitute_type("OBJECT IDENTIFIER"), do: "rust_asn1::ObjectIdentifier"
  def substitute_type("ANY"),               do: "Vec<u8>"
  def substitute_type("NULL"),              do: "()"
  def substitute_type("Int"),               do: "i64"
  def substitute_type("ASN1BitString"),     do: "rust_asn1::BitString"
  def substitute_type("ASN1OctetString"),   do: "Vec<u8>"
  def substitute_type("ASN1UTF8String"),    do: "String"
  def substitute_type("ASN1IA5String"),     do: "String"
  def substitute_type("ASN1PrintableString"), do: "String"
  def substitute_type("ASN1NumericString"), do: "String"
  def substitute_type("ASN1VisibleString"), do: "String"
  def substitute_type("ASN1GeneralString"), do: "String"
  def substitute_type("ASN1UniversalString"), do: "String"
  def substitute_type("ASN1BMPString"),     do: "String"
  def substitute_type("ASN1ObjectIdentifier"), do: "rust_asn1::ObjectIdentifier"
  def substitute_type("ASN1Null"),          do: "()"
  def substitute_type("ASN1Any"),           do: "Vec<u8>"
  def substitute_type("EXTERNAL"),          do: "Vec<u8>"

  def substitute_type(t) do
    key = try do
      String.to_existing_atom(t)
    rescue
      _ -> nil
    end

    case key do
      nil -> t
      k -> :application.get_env(:asn1scg, k, t)
    end
  end

  defp is_primitive(t) do
      t in ["i64", "bool", "String", "()"] or
      String.starts_with?(t, "Vec<") or
      String.starts_with?(t, "Option<") or
      String.starts_with?(t, "crate::") or
      String.starts_with?(t, "rust_asn1::")
  end

  def emit_sequence(name, fields, _mod) do
    imports = get_imports_from_fields(fields)
    body = """
    #[derive(Debug, Clone, PartialEq)]
    pub struct #{name} {
    #{emit_fields(fields)}
    }
    """
    emit_imprint() <> "\n" <> add_imports(body, imports, name)
  end

  def emit_set(name, fields, mod), do: emit_sequence(name, fields, mod)

  def emit_choice(name, cases, _mod) do
    imports = get_imports_from_fields(cases)
    body = """
    #[derive(Debug, Clone, PartialEq)]
    pub enum #{name} {
    #{emit_enum_cases(cases)}
    }
    """
    emit_imprint() <> "\n" <> add_imports(body, imports, name)
  end

  def emit_enumeration(name, cases, _mod) do
    body = """
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum #{name} {
    #{emit_enum_cases(cases)}
    }
    """
    emit_imprint() <> "\n" <> body
  end

  def emit_integer_enum(name, cases, _mod) do
    body = """
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum #{name} {
    #{emit_enum_cases(cases)}
    }
    """
    emit_imprint() <> "\n" <> body
  end

  def emit_typealias(name, type, _mod) do
      t = substitute_type(type)
      imports = get_imports(type)
      body = "pub type #{name} = #{t};"
      emit_imprint() <> "\n" <> add_imports(body, imports, name)
  end

  def emit_constant(name, val, _mod, _type \\ nil) do
      "// pub const #{name} = #{inspect(val)};"
  end

  def emit_array(name, type, _tag, _mod) do
      t = substitute_type(type)
      imports = get_imports(type)
      body = "pub type #{name} = Vec<#{t}>;"
      emit_imprint() <> "\n" <> add_imports(body, imports, name)
  end

  def emit_oid_value(name, _def, _mod) do
      "// OID #{name}"
  end

  # Helpers

  defp add_imports(content, imports, self_name) do
      lines = imports
        |> Enum.uniq()
        |> Enum.reject(&(&1 == self_name))
        |> Enum.map(fn t -> "use crate::generated::#{t}::#{t};" end)
        |> Enum.join("\n")

      if lines == "", do: content, else: lines <> "\n\n" <> content
  end

  defp get_imports_from_fields(fields) when is_list(fields) do
      fields
      |> Enum.flat_map(&get_imports/1)
      |> Enum.uniq()
  end
  defp get_imports_from_fields(_), do: []

  defp get_imports({:type, _, inner, _, _, _}), do: get_imports(inner)
  defp get_imports({:"SEQUENCE OF", inner}), do: get_imports(inner)
  defp get_imports({:"SET OF", inner}), do: get_imports(inner)
  defp get_imports({:ComponentType, _, _, type, _, _, _}), do: get_imports(type)
  defp get_imports({:Externaltypereference, _, _, name}), do: get_imports(to_string(name))
  defp get_imports({:NamedNumber, _, _}), do: []
  defp get_imports({name, _}) when is_atom(name), do: [] # Enum value
  defp get_imports(t) when is_atom(t), do: get_imports(to_string(t))
  defp get_imports(t) when is_binary(t) do
      res = substitute_type(t)
      if is_primitive(res), do: [], else: [res]
  end
  defp get_imports(_), do: []

  defp emit_fields(fields) do
      fields
      |> Enum.map(fn
          {:ComponentType, _, name, type, optional, _, _} ->
              fname = snake_case(to_string(name))
              ftype = type_string(type)
              final_type = if optional == :OPTIONAL, do: "Option<#{ftype}>", else: ftype
              "    pub #{fname}: #{final_type},"
          _ -> ""
      end)
      |> Enum.join("\n")
  end

  defp emit_enum_cases(cases) do
      cases
      |> Enum.map(fn
          {:NamedNumber, name, _val} ->
              "    #{to_string(name)},"
          {name, _val} ->
              "    #{to_string(name)},"
          {:ComponentType, _, name, type, _, _, _} ->
              # For CHOICE
               t = type_string(type)
              "    #{to_string(name)}(#{t}),"
          _ -> ""
      end)
      |> Enum.join("\n")
  end

  defp type_string({:type, _, inner, _, _, _}), do: type_string(inner)
  defp type_string({:"SEQUENCE OF", inner}), do: "Vec<#{type_string(inner)}>"
  defp type_string({:"SET OF", inner}), do: "Vec<#{type_string(inner)}>"
  defp type_string(atom) when is_atom(atom), do: substitute_type(to_string(atom))
  defp type_string({:Externaltypereference, _, _, name}), do: substitute_type(to_string(name))
  defp type_string(other), do: substitute_type(inspect(other))

  defp snake_case(str) do
      str
      |> String.replace("-", "_")
      |> String.downcase
  end
end
