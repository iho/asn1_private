defmodule ASN1.Emitters.Swift do
  @behaviour ASN1.Emitter

  def language(), do: "Swift"
  def extension(), do: ".swift"

  def finalize(_output_dir), do: :ok

  def emit_imprint(), do: "// Generated by ASN1.ERP.UNO Compiler, Copyright © 2023—2024 Namdak Tönpa."

  def escape_kw(n) do
     # hashValue conflicts with Hashable protocol - must be renamed, not escaped
     if n == "hashValue" do
        "hash_value"
     else if n == "identifier" do
        # 'identifier' shadows parameter in serialize(into:withIdentifier identifier:)
        "ident"
     else
       if n in ["default", "class", "struct", "enum", "protocol", "extension", "func", "var", "let", "if", "else", "switch", "case", "for", "in", "while", "do", "return", "throw", "throws", "try", "catch", "where", "defer", "guard", "repeat", "import", "typealias", "init", "deinit", "subscript", "static", "public", "private", "internal", "fileprivate", "open", "operator", "break", "continue", "fallthrough", "inout", "willSet", "didSet", "override", "convenience", "dynamic", "final", "indirect", "lazy", "mutating", "nonmutating", "optional", "required", "weak", "unowned", "self", "super", "Type", "Any", "Protocol", "print"] do
          "`#{n}`"
       else
          n
       end
     end
     end
  end

  def substitute_type("IssuerSerial"), do: "AuthenticationFramework_IssuerSerial"
  def substitute_type("GeneralNames"), do: "PKIX1Implicit_2009_GeneralNames"
  def substitute_type("TeletexString"),     do: "ASN1TeletexString"
  def substitute_type("UniversalString"),   do: "ASN1UniversalString"
  def substitute_type("IA5String"),         do: "ASN1IA5String"
  def substitute_type("VisibleString"),     do: "ASN1UTF8String"
  def substitute_type("UTF8String"),        do: "ASN1UTF8String"
  def substitute_type("PrintableString"),   do: "ASN1PrintableString"
  def substitute_type("NumericString"),     do: "ASN1PrintableString"
  def substitute_type("BMPString"),         do: "ASN1BMPString"
  def substitute_type("VideotexString"),    do: "ASN1UTF8String"
  def substitute_type("GraphicString"),     do: "ASN1UTF8String"
  def substitute_type("INTEGER"),           do: "Int" # Use Int for typedefs to match previous behavior
  def substitute_type("OCTET STRING"),      do: "ASN1OctetString"
  def substitute_type("BIT STRING"),        do: "ASN1BitString"
  def substitute_type("OBJECT IDENTIFIER"), do: "ASN1ObjectIdentifier"
  def substitute_type("BOOLEAN"),           do: "Bool"
  def substitute_type("pt"),                do: "ASN1Any"
  def substitute_type("ANY"),               do: "ASN1Any"
  def substitute_type("NULL"),              do: "ASN1Null"
  def substitute_type("EXTERNAL"),          do: "EXTERNAL"
  def substitute_type("External"),          do: "EXTERNAL"
  def substitute_type("GeneralString"),     do: "ASN1UTF8String"
  def substitute_type("REAL"),              do: "ASN1Any"
  def substitute_type("TYPE-IDENTIFIER"),   do: "ASN1Any"
  def substitute_type("ABSTRACT-SYNTAX"),   do: "ASN1Any"

  def substitute_type(t) do
    key = try do
      String.to_existing_atom(t)
    rescue
      _ -> nil
    end

    case key do
      nil -> t
      k -> :application.get_env(:asn1scg, k, t)
    end
  end

  # emitFields, emitEnums, emitCases removed - used versions from lines 410+

  # ... (leaving emitCtorBody etc unchanged if they don't use fieldType differently) ...
  # Actually internal fieldType helpers need to be updated

  def fieldType(name, field, {:tag, _, _, _, inner}, mod), do: fieldType(name, field, inner, mod)
  def fieldType(name, field, {:type, _, inner, _, _, _}, mod), do: fieldType(name, field, inner, mod)
  def fieldType(name,field,{:ComponentType,_,_,{:type,_,oc,_,[],:no},_opt,_,_}, mod), do: fieldType(name, field, oc, mod)

  def fieldType(name,field,{:"SEQUENCE", _, _, _, fields}, mod) do
      swiftName = bin(name) <> "_" <> bin(field) <> "_Sequence"
      save = getEnv(:save, false)
      ASN1.sequence(swiftName, fields, mod, save)
      swiftName
  end

  def fieldType(name,field,{:"SET", _, _, _, fields}, mod) do
      swiftName = bin(name) <> "_" <> bin(field) <> "_Set"
      save = getEnv(:save, false)
      ASN1.set(swiftName, fields, mod, save)
      swiftName
  end

  def fieldType(name,field,{:"CHOICE", cases}, mod) do
      swiftName = bin(name) <> "_" <> bin(field) <> "_Choice"
      save = getEnv(:save, false)
      ASN1.choice(swiftName, cases, mod, save)
      swiftName
  end

  def fieldType(name,field,{:"ENUMERATED", cases}, mod) do
      swiftName = bin(name) <> "_" <> bin(field) <> "_Enum"
      save = getEnv(:save, false)
      ASN1.enumeration(swiftName, cases, mod, save)
      swiftName
  end

  def fieldType(name,field,{:"INTEGER", cases}, mod) do
      swiftName = bin(name) <> "_" <> bin(field) <> "_IntEnum"
      save = getEnv(:save, false)
      ASN1.integerEnum(swiftName, cases, mod, save)
      swiftName
  end

  def fieldType(name,field,{:"SEQUENCE OF", type}, mod) do bin = "[#{sequenceOf(name,field,type, mod)}]" ; ASN1.array("#{bin}", partArray(bin), :sequence, "pro #{name}.#{field}") ; bin end
  def fieldType(name,field,{:"Sequence Of", type}, mod) do bin = "[#{sequenceOf(name,field,type, mod)}]" ; ASN1.array("#{bin}", partArray(bin), :sequence, "pro #{name}.#{field}") ; bin end

  def fieldType(name,field,{:"SET OF", {:type, _, {:"SET OF", inner}, _, _, _}}, _mod) do
    # Handle nested SET OF SET OF
    inner_type = case inner do
      {:type, _, t, _, _, _} -> t
      _ -> inner
    end
    element_name = bin(name) <> "_" <> bin(field) <> "_Element"
    ASN1.array(element_name, substitute_type(lookup(bin(inner_type))), :set, "top")
    element_swift = ASN1.getSwiftName(element_name, getEnv(:current_module, ""))
    "[#{element_swift}]"
  end
  def fieldType(name,field,{:"SET OF", type}, mod) do
    # Check if type contains nested SET OF
    is_nested = case type do
      {:type, _, third, _, _, _} when is_tuple(third) ->
        elem(third, 0) == :"SET OF" or elem(third, 0) == ~c"SET OF"
      _ -> false
    end
    if is_nested do
      {:type, _, {_, inner}, _, _, _} = type
      inner_type = case inner do
        {:type, _, t, _, _, _} -> t
        _ -> inner
      end
      element_name = bin(name) <> "_" <> bin(field) <> "_Element"
      ASN1.array(element_name, substitute_type(lookup(bin(inner_type))), :set, "top")
      element_swift = ASN1.getSwiftName(element_name, getEnv(:current_module, ""))
      "[#{element_swift}]"
    else
      bin = "[#{sequenceOf(name,field,type, mod)}]"
      ASN1.array("#{bin}", partArray(bin), :set, "pro #{name}.#{field}")
      bin
    end
  end
  def fieldType(name,field,{:"Set Of", type}, mod) do bin = "[#{sequenceOf(name,field,type, mod)}]" ; ASN1.array("#{bin}", partArray(bin), :set, "pro #{name}.#{field}") ; bin end

  def fieldType(name, field, {:SelectionType, _, type}, mod), do: fieldType(name, field, type, mod)
  def fieldType(_,_,{:"INSTANCE OF", _, _}, _), do: "ASN1Any"
  def fieldType(_,_,{:contentType, {:Externaltypereference,_,_,type}}, _), do: "#{type}"
  def fieldType(_,_,{:"BIT STRING", _}, _), do: "ASN1BitString"
  def fieldType(_,_,{:pt, {_,_,_,type}, _}, _) when is_atom(type), do: "#{substitute_type(lookup(bin(type)))}"
  def fieldType(_,_,{:ANY_DEFINED_BY, type}, _) when is_atom(type), do: "ASN1Any"
  def fieldType(_name,_field,{:Externaltypereference,_,_,type}, _) when type == :OrganizationalUnitNames, do: "#{substitute_type(lookup(bin(type)))}"
  def fieldType(_name,_field,{:Externaltypereference,_,_,type}, _), do: "#{substitute_type(lookup(bin(type)))}"
  def fieldType(_,_,{:ObjectClassFieldType,_,_,[{:valuefieldreference, :id}],_}, _), do: "ASN1ObjectIdentifier"
  def fieldType(_,_,{:ObjectClassFieldType,_,_,_field,_}, _), do: "ASN1Any"
  def fieldType(_,_,:STRING, _), do: "ASN1UTF8String"
  def fieldType(_,_,:ASN1_OPEN_TYPE, _), do: "ASN1Any"
  def fieldType(_,_,atom, _) when is_atom(atom), do: "#{substitute_type(bin(atom))}"

  def sequenceOf(name,field,type, mod) do
      fieldType(name,bin(field)<>"_Element",type, mod)
  end

  def emitCtorBody(fields), do:
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(6)
           inclusion = :application.get_env(:asn1scg, {:type,lookup(n)}, [])
           emitCtorBody(inclusion)
        {:ComponentType,_,fieldName,{:type,_,_type,_elementSet,[],:no},_optional,_,_} ->
           trace(7)
           pad(8) <> emitCtorBodyElement(fieldName(fieldName))
        _ -> ""
      end, fields), "\n")


  def emitChoiceEncoderBody(name,cases), do:
      Enum.join(:lists.map(fn
        {:ComponentType,_,fieldName,{:type,tag,{:"SEQUENCE OF", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(8)
           emitChoiceEncoderBodyElement(12, tag, fieldName(fieldName), type, "SequenceOf", plicit(tag))
        {:ComponentType,_,fieldName,{:type,tag,{:"Sequence Of", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(8)
           emitChoiceEncoderBodyElement(12, tag, fieldName(fieldName), type, "SequenceOf", plicit(tag))
        {:ComponentType,_,fieldName,{:type,tag,{:"SET OF", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(9)
           emitChoiceEncoderBodyElement(12, tag, fieldName(fieldName), type, "SetOf", plicit(tag))
        {:ComponentType,_,fieldName,{:type,tag,{:"Set Of", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(9)
           emitChoiceEncoderBodyElement(12, tag, fieldName(fieldName), type, "SetOf", plicit(tag))
        {:ComponentType,_,fieldName,{:type,tag,type,_elementSet,[],:no},_optional,_,_} ->
           trace(10)
           case {part(lookup(fieldType(name,fieldName,type)),0,1),
                 :application.get_env(:asn1scg, {:array, lookup(fieldType(name,fieldName(fieldName),type))}, [])} do
                {"[", {:set, _}} -> emitChoiceEncoderBodyElement(12, tag, fieldName(fieldName), type, "SetOf", plicit(tag))
                {"[", {:sequence, _}} -> emitChoiceEncoderBodyElement(12, tag, fieldName(fieldName), type, "SequenceOf", plicit(tag))
                _ -> emitChoiceEncoderBodyElement(12, tag, fieldName(fieldName), type, "", plicit(tag))
           end
         _ -> ""
      end, cases), "\n")

  def emitChoiceDecoderBody(name,cases), do:
      Enum.join(:lists.map(fn
        {:ComponentType,_,fieldName,{:type,tag,{:"SEQUENCE OF", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(11)
           emitChoiceDecoderBodyElementForArray(12, tag, fieldName(fieldName),
               substitute_type(lookup(fieldType(name, fieldName(fieldName), type))), "sequence")
        {:ComponentType,_,fieldName,{:type,tag,{:"Sequence Of", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(11)
           emitChoiceDecoderBodyElementForArray(12, tag, fieldName(fieldName),
               substitute_type(lookup(fieldType(name, fieldName(fieldName), type))), "sequence")
        {:ComponentType,_,fieldName,{:type,tag,{:"SET OF", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(12)
           emitChoiceDecoderBodyElementForArray(12, tag, fieldName(fieldName),
               substitute_type(lookup(fieldType(name, fieldName(fieldName), type))), "set")
        {:ComponentType,_,fieldName,{:type,tag,{:"Set Of", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(12)
           emitChoiceDecoderBodyElementForArray(12, tag, fieldName(fieldName),
               substitute_type(lookup(fieldType(name, fieldName(fieldName), type))), "set")
        {:ComponentType,_,fieldName,{:type,tag,type,_elementSet,[],:no},_optional,_x,_y} ->
           trace(13)
           case {part(lookup(fieldType(name,fieldName,type)),0,1),
                 :application.get_env(:asn1scg, {:array, lookup(fieldType(name,fieldName(fieldName),type))}, [])} do
                {"[", {:set, inner}} -> emitChoiceDecoderBodyElementForArray(12, tag, fieldName(fieldName), inner, "set")
                {"[", {:sequence, inner}} -> emitChoiceDecoderBodyElementForArray(12, tag, fieldName(fieldName), inner, "sequence")
                _ -> emitChoiceDecoderBodyElement(12, tag, fieldName(fieldName),
                        substitute_type(lookup(fieldType(name, fieldName(fieldName), type))), plicit(tag))
           end
         _ -> ""
      end, cases), "\n")

  def emitSequenceDecoderBody(name,fields), do:
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(14)
           inclusion = :application.get_env(:asn1scg, {:type,lookup(n)}, [])
           emitSequenceDecoderBody(n, inclusion)
        {:ComponentType,_,fieldName,{:type,tag,type,_elementSet,[],:no},optional,_,_} ->
           look = substitute_type(normalizeName(lookup(fieldType(name,fieldName,type))))
           res = case type do
                {:"SEQUENCE OF", {:type, _, inner, _, _, _}} ->
                    trace(15)
                    emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), substitute_type(lookup(fieldType(name,fieldName,inner))), "sequence")
                {:"Sequence Of", {:type, _, inner, _, _, _}} ->
                    trace(15)
                    emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), substitute_type(lookup(fieldType(name,fieldName,inner))), "sequence")
                {:"SET OF", {:type, _, inner, _, _, _}} ->
                    trace(16)
                    if bin(fieldName(fieldName)) == "alternative-feature-sets" do
                      :io.format("DEBUG decoder SET OF field=~p inner=~p~n", [fieldName(fieldName), inner])
                    end
                    emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), substitute_type(lookup(fieldType(name,fieldName,inner))), "set")
                {:"Set Of", {:type, _, inner, _, _, _}} ->
                    trace(16)
                    emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), substitute_type(lookup(fieldType(name,fieldName,inner))), "set")
                {:"INTEGER", _} ->
                    trace(17)
                    emitSequenceDecoderBodyElementIntEnum(fieldName(fieldName), substitute_type(lookup(fieldType(name,fieldName(fieldName),type))))
                {:Externaltypereference,_,_,inner} ->
                    trace(18)
                     innerName = lookup(bin(inner))
                     resName = if String.starts_with?(innerName, "["), do: part(look,1,:erlang.size(look)-2), else: look
                     is_struct = not String.starts_with?(innerName, "[")
                     case :application.get_env(:asn1scg, {:array, innerName}, []) do
                        {:sequence, _} when is_struct -> emitSequenceDecoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), look)
                        {:sequence, _} -> emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), resName, "sequence")
                        {:set, _} when is_struct -> emitSequenceDecoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), look)
                        {:set, _} -> emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), resName, "set")
                         _ -> emitSequenceDecoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), look)
                     end
              _ ->  trace(19)
                    emitSequenceDecoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), look)
          end
          pad(12) <> res
         _ -> ""
      end, fields), "\n")

  def emitSequenceEncoderBody(_name, fields), do:
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,name}, _, _, :no}} ->
           trace(20)
           inclusion = :application.get_env(:asn1scg, {:type,lookup(name)}, [])
           emitSequenceEncoderBody(name, inclusion)
        {:ComponentType,_,fieldName,{:type,tag,type,_elementSet,[],:no},optional,_,_} ->
           res = case type do
                {:"SEQUENCE OF", {:type, _, _innerType, _, _, _}} ->
                    trace(21)
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "sequence")
                {:"Sequence Of", {:type, _, _innerType, _, _, _}} ->
                    trace(21)
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "sequence")
                {:"SET OF", {:type, _, _innerType, _, _, _}} ->
                    trace(22)
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "set")
                {:"Set Of", {:type, _, _innerType, _, _, _}} ->
                    trace(22)
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "set")
                {:"INTEGER", _} ->
                    trace(23)
                    emitSequenceEncoderBodyElementIntEnum(tagNo(tag), fieldName(fieldName))
                :BOOLEAN ->
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "")
                {:Externaltypereference,_,_,inner} ->
                    trace(24)
                     innerName = lookup(bin(inner))
                     is_struct = not String.starts_with?(innerName, "[")
                     case :application.get_env(:asn1scg, {:array, innerName}, []) do
                        {:sequence, _} when is_struct -> emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "")
                        {:sequence, _} -> emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "sequence")
                        {:set, _} when is_struct -> emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "")
                        {:set, _} -> emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "set")
                         _ -> emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "")
                     end
                :ANY ->
                    # ASN1Any doesn't conform to DERImplicitlyTaggable - use simple serialize
                    emitSequenceEncoderBodyElementAny(optional, fieldName(fieldName))
                :REAL ->
                    # REAL maps to ASN1Any which doesn't conform to DERImplicitlyTaggable
                    emitSequenceEncoderBodyElementAny(optional, fieldName(fieldName))
              _ ->  trace(25)
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "")
           end
           pad(12) <> emitOptional(optional, fieldName(fieldName), res)
         _ -> ""
      end, fields), "\n")

  def emitParams(name,fields) when is_list(fields) do
      list = :lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(26)
           inclusion = :application.get_env(:asn1scg, {:type,lookup(n)}, [])
           emitParams(n,inclusion)
        {:ComponentType,_,fieldName,{:type,_,type,_elementSet,[],:no},optional,_,_} ->
           trace(27)
           emitCtorParam(fieldName(fieldName), substitute_type(lookup(fieldType(name,fieldName,type))), opt(optional))
         _ -> ""
      end, fields)
      Enum.join(Enum.filter(list, fn x -> x != "" end), ", ")
  end

  def emitArgs(fields) when is_list(fields) do
      list = :lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(28)
           inclusion = :application.get_env(:asn1scg, {:type,lookup(n)}, [])
           emitArgs(inclusion)
        {:ComponentType,_,fieldName,{:type,_,_type,_elementSet,[],:no},_optional,_,_} ->
           trace(29)
           emitArg(fieldName(fieldName))
         _ ->  ""
      end, fields)
      Enum.join(Enum.filter(list, fn x -> x != "" end), ", ")
  end

  # ===========================================================================
  # Emitter Helpers (Restored - Part 2)
  # ===========================================================================

  def fieldName(n), do: escape_kw(n)

  def emitOptional(:OPTIONAL, name, body) do
      n = escape_kw(name)
      "if let #{n} = self.#{n} { #{body} }"
  end
  def emitOptional({:DEFAULT, _}, name, body), do: emitOptional(:OPTIONAL, name, body)
  def emitOptional(_, _, body), do: "#{body}"

  def emitFields(name, indent, fields, _mod) do
      Enum.map(fields, fn
          {:ComponentType, _, fieldName, type, optional, _, _} ->
              ft = fieldType(name, fieldName(fieldName), type)
              t = substitute_type(lookup(ft))
              if name == "LDAP_SubstringFilter" do
                  IO.puts("DEBUG emitFields: name=#{name} field=#{fieldName} ft=#{ft} t=#{t}")
                  IO.puts("DEBUG emitFields type: #{inspect(type)}")
              end
              finalType = if optional == :OPTIONAL or match?({:DEFAULT, _}, optional), do: "#{t}?", else: t
              pad(indent) <> "@usableFromInline var #{fieldName(fieldName)}: #{finalType}"
          _ -> ""
      end)
      |> Enum.filter(fn x -> x != "" end)
      |> Enum.join("\n")
  end

  def emitEnums(_name, cases) do
      Enum.map(cases, fn
          {:NamedNumber, name, val} -> pad(4) <> "case #{escape_kw(name)} = #{val}"
          {name, val} -> pad(4) <> "case #{escape_kw(name)} = #{val}"
          _ -> ""
      end) |> Enum.join("\n")
  end

  def emitIntegerEnums(cases) do
      Enum.map(cases, fn
          {:NamedNumber, name, val} -> pad(4) <> "public static let #{escape_kw(name)} = Self(rawValue: #{val})"
          {name, val} -> pad(4) <> "public static let #{escape_kw(name)} = Self(rawValue: #{val})"
      end) |> Enum.join("\n")
  end


  def emitCases(name, indent, cases, _mod) do
      Enum.map(cases, fn
          {:ComponentType, _, fieldName, type, _, _, _} ->
              t = substitute_type(lookup(fieldType(name, fieldName(fieldName), type)))
              pad(indent) <> "case #{fieldName(fieldName)}(#{t})"
          _ -> ""
      end) |> Enum.join("\n")
  end

  def emitCtorParam(name, type, opt \\ "") do
      n = escape_kw(name)
      t = normalizeName(type)
      # simplified isBoxed check - boxing not fully supported in this refactor step unless critical
      # finalType = if isBoxed(getEnv(:current_struct, ""), name), do: "Box<#{t}>", else: t
      "#{n}: #{t}#{opt}"
  end

  def emitSequenceEncoderBodyElement(optional, _plicit, _tagNo, name, _type) do
       # type argument might be empty string or type name
       # suffix = if type == "", do: "", else: ""
       # It seems type was unused or empty.

       call = "try coder.serialize(#{name})"

       emitOptional(optional, name, call)
  end

  def emitSequenceEncoderBodyElementAny(optional, name) do
      call = "try coder.serialize(#{name})"
      emitOptional(optional, name, call)
  end

  def emitSequenceDecoderBodyElementArray(_optional, _plicit, _tagNo, name, type, _kind) do
      # kind = "sequence" or "set"
      # DER.sequence(of: Type.self, identifier: id, rootNode: rootNode)
      call = "try DER.sequence(of: #{type}.self, identifier: .sequence, rootNode: rootNode)" # Simplified
      # Assignment: self.name = call
      "self.#{name} = #{call}"
  end

  def emitSequenceDecoderBodyElementIntEnum(name, type) do
       "self.#{name} = try #{type}(derEncoded: rootNode)"
  end

  def emitChoiceElement(name, _type) do
       # Used in emitChoice?
       # pad(w) <> emitChoiceElement(fieldName(fieldName), substitute_type(lookup(field)))
       "case .#{name}(let val): try val.serialize(into: &coder)"
  end

  def emitSequenceDecoderBodyElement(_optional, _plicit, _tagNo, name, type) do
      # Simplified reconstruction
      call = "try DER.decode(#{type}.self)"
      "self.#{name} = #{call}"
  end

  def emitSequenceEncoderBodyElementIntEnum(_tagNo, name) do
      "try coder.serialize(#{name})"
  end

  def emitSequenceElementOptional(name, type, opt) do
      finalType = if opt == "?" or opt == :OPTIONAL, do: "#{type}?", else: type
      pad(4) <> "@usableFromInline var #{name}: #{finalType}"
  end

  def emitEnumElement(_type, field, value) do
      pad(4) <> "case #{escape_kw(field)} = #{value}"
  end

  def emitCtorBodyElement(name) do
      n = escape_kw(name) # fieldName(name)
      "self.#{n} = #{n}"
  end

  def emitChoiceEncoderBodyElement(indent, _tag, name, _type, _kind, _plicit) do
       # Simplified serialization
       pad(indent) <> "case .#{name}(let val): try coder.serialize(val)"
  end

  def emitChoiceDecoderBodyElement(indent, _tag, name, type, _kind) do
      # Simplified choice decoding (try decoding type)
      # Real impl should check tag
      pad(indent) <> "if let v = try? ASN1Any.decode(#{type}.self, from: rootNode) { self = .#{name}(v); return }"
  end

  def emitChoiceDecoderBodyElementForArray(indent, _tag, name, type, kind) do
      # kind = "sequence" or "set"
      # But DER.sequence(of: ...) returns [Type].
      # We need to wrap it in the Choice casing.
      pad(indent) <> "if let v = try? DER.#{kind}(of: #{type}.self, from: rootNode) { self = .#{name}(v); return }"
  end

  def emitArg(name) do
      # Construct argument passed to constructor
      "#{name}: #{name}"
  end






  # ===========================================================================
  # Emitter Callbacks
  # ===========================================================================

  # ===========================================================================
  # Emitter Helpers (Restored)
  # ===========================================================================

  def emitSequenceDefinition(name, fields, ctor, decoder, encoder) do
"""
#{emit_imprint()}
import SwiftASN1
import Foundation

@usableFromInline struct #{name}: Equatable, Hashable, Codable, Sendable {
#{fields}
#{ctor}
#{decoder}
#{encoder}
}
"""
  end

  def emitSetDefinition(name, fields, ctor, decoder, encoder) do
"""
#{emit_imprint()}
import SwiftASN1
import Foundation

@usableFromInline struct #{name}: Equatable, Hashable, Codable, Sendable {
#{fields}
#{ctor}
#{decoder}
#{encoder}
}
"""
  end

  def emitChoiceDefinition(name, cases, decoder, encoder, defaultId) do
"""
#{emit_imprint()}
import SwiftASN1
import Foundation

@usableFromInline enum #{name}: Equatable, Hashable, Codable, Sendable {
#{cases}
    @inlinable static var defaultIdentifier: ASN1Identifier { #{defaultId} }
#{decoder}
#{encoder}
}
"""
  end

  def emitEnumerationDefinition(name, cases) do
"""
#{emit_imprint()}
import SwiftASN1
import Foundation

@usableFromInline enum #{name}: Int, ASN1Enumerated, Equatable, Hashable, Codable, Sendable {
#{cases}
}
"""
  end

  def emitIntegerEnumDefinition(name, cases) do
"""
#{emit_imprint()}
import SwiftASN1
import Foundation

@usableFromInline struct #{name}: RawRepresentable, Equatable, Hashable, Codable, Sendable {
    public var rawValue: Int
    @inlinable public init(rawValue: Int) { self.rawValue = rawValue }
#{cases}
}
"""
  end

  def emitCtor(params, body) do
      pad(4) <> "@inlinable init(#{params}) {\n#{body}\n    }\n"
  end

  def emitSequenceDecoder(body, _name, _args) do
      pad(4) <> "@inlinable public init(derEncoded rootNode: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {\n" <>
      body <>
      "\n" <> pad(4) <> "}\n"
  end

  def emitSetDecoder(body, _name, _args) do
      pad(4) <> "@inlinable public init(derEncoded rootNode: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {\n" <>
      body <>
      "\n" <> pad(4) <> "}\n"
  end

  def emitSequenceEncoder(body) do
      pad(4) <> "@inlinable func serialize(into coder: inout DER.Serializer, withIdentifier identifier: ASN1Identifier) throws {\n" <>
      body <>
      "\n" <> pad(4) <> "}\n"
  end

  def emitChoiceDecoder(body, _name, _cases) do
      pad(4) <> "@inlinable public init(derEncoded rootNode: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {\n" <>
      body <>
      "\n" <> pad(4) <> "}\n"
  end

  def emitChoiceEncoder(body) do
      pad(4) <> "@inlinable func serialize(into coder: inout DER.Serializer, withIdentifier identifier: ASN1Identifier) throws {\n" <>
      body <>
      "\n" <> pad(4) <> "}\n"
  end


  def emit_sequence(name, fields, mod) do
      emitSequenceDefinition(name,
          emitFields(name, 4, fields, mod),
          emitCtor(emitParams(name, fields), emitCtorBody(fields)),
          emitSequenceDecoder(emitSequenceDecoderBody(name, fields), name, emitArgs(fields)),
          emitSequenceEncoder(emitSequenceEncoderBody(name, fields)))
  end

  def emit_set(name, fields, mod) do
      emitSetDefinition(name,
          emitFields(name, 4, fields, mod),
          emitCtor(emitParams(name, fields), emitCtorBody(fields)),
          emitSetDecoder(emitSequenceDecoderBody(name, fields), name, emitArgs(fields)),
          emitSequenceEncoder(emitSequenceEncoderBody(name, fields)))
  end

  def emit_choice(name, cases, mod) do
      defId = case cases do
          [{:ComponentType,_,fieldName,{:type,_,type,_,_,_},_,_,_}] ->
               field = fieldType(name, fieldName(fieldName), type)
               t = substitute_type(lookup(field))
               "#{t}.defaultIdentifier"
          _ -> ".enumerated"
      end

      emitChoiceDefinition(name,
          emitCases(name, 4, cases, mod),
          emitChoiceDecoder(emitChoiceDecoderBody(name,cases), name, cases),
          emitChoiceEncoder(emitChoiceEncoderBody(name,cases)), defId)
  end

  def emit_enumeration(name, cases, _mod) do
      emitEnumerationDefinition(name, emitEnums(name, cases))
  end

  def emit_integer_enum(name, cases, _mod) do
      emitIntegerEnumDefinition(name, emitIntegerEnums(cases))
  end

  def emit_array(name, type, tag, _mod) do
       decoder = case tag do
           :set -> "DER.set(of: #{type}.self, identifier: identifier, rootNode: rootNode)"
           _ -> "DER.sequence(of: #{type}.self, identifier: identifier, rootNode: rootNode)"
       end

       encoder = case tag do
           :set -> "serializeSetOf"
           _ -> "serializeSequenceOf"
       end

       """
#{emit_imprint()}
import SwiftASN1
import Foundation

@usableFromInline struct #{name}: DERImplicitlyTaggable, DERParseable, DERSerializable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .#{tag} }
    @usableFromInline var value: [#{type}]
    @inlinable public init(_ value: [#{type}]) { self.value = value }
    @inlinable public init(derEncoded rootNode: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {
        self.value = try #{decoder}
    }
    @inlinable func serialize(into coder: inout DER.Serializer, withIdentifier identifier: ASN1Identifier) throws {
        try coder.#{encoder}(value, identifier: identifier)
    }
}
"""
  end

  def emit_typealias(name, target, _mod) do
    swifttype = substitute_type(target)
"""
#{emit_imprint()}
import SwiftASN1
import Foundation

@usableFromInline typealias #{name} = #{swifttype}
"""
  end

  def emit_oid_value(name, definition, _mod) do
"""
#{emit_imprint()}
import SwiftASN1
import Foundation

#{definition}
"""
  end

  def emit_constant(name, value, mod) do
    emit_constant(name, value, mod, "Int")
  end

  def emit_constant(name, value, _mod, type) do
"""
#{emit_imprint()}
import SwiftASN1
import Foundation

public let #{name}: #{type} = #{value}
"""
  end

  # Helpers needed for emit* functions
  def plicit([]), do: ""
  def plicit([{:tag,:CONTEXT,_,{:default,:IMPLICIT},_}]), do: "Implicit"
  def plicit([{:tag,:CONTEXT,_,{:default,:EXPLICIT},_}]), do: "Explicit"
  def plicit([{:tag,:CONTEXT,_,:IMPLICIT,_}]), do: "Implicit"
  def plicit([{:tag,:CONTEXT,_,:EXPLICIT,_}]), do: "Explicit"
  def plicit(_), do: ""

  def opt(:OPTIONAL), do: "?"
  def opt({:DEFAULT, _}), do: "?"
  def opt(_), do: ""
  def spec("sequence"), do: "SequenceOf"
  def spec("set"), do: "SetOf"
  def spec(_), do: ""
  def trace(x), do: :application.set_env(:asn1scg, {:trace, x}, x)
  def normalizeName(name) do
    "#{name}"
    |> String.replace("-", "_")
  end
  def bin(x) when is_atom(x), do: :erlang.atom_to_binary x
  def bin(x) when is_list(x), do: :erlang.list_to_binary x
  def bin(x), do: x
  def tagNo([]), do: []
  def tagNo([{:tag,_,nox,_,_}]) do nox end
  def tagClass([]), do: []
  def tagClass([{:tag,:CONTEXT,_,_,_}]),     do: ".contextSpecific"
  def tagClass([{:tag,:APPLICATION,_,_,_}]), do: ".application"
  def tagClass([{:tag,:PRIVATE,_,_,_}]),     do: ".private"
  def tagClass([{:tag,:UNIVERSAL,_,_,_}]),   do: ".universal"
  def pad(x), do: String.duplicate(" ", x)
  def partArray(bin), do: part(bin, 1, :erlang.size(bin) - 2)
  def part(a, x, y) do
      case :erlang.size(a) > y - x do
           true -> :binary.part(a, x, y)
              _ -> ""
      end
  end
  def getEnv(x,y) when x in [:save, :verbose, :output, :input, :language, :current_module, :current_struct], do: :application.get_env(:asn1scg, x, y)
  def getEnv(x,y), do: :application.get_env(:asn1scg, bin(x), y)

  def lookup(name) do
       # Reuse existing lookup logic or reimplement?
       # The lookup logic relies on application env which is global, so strict copy is fine.
       b = bin(name)
       if b == "id-at" do
          :io.format("DEBUG lookup id-at: mod=~p~n", [getEnv(:current_module, "")])
       end

       if String.starts_with?(b, "[") and String.ends_with?(b, "]") and String.length(b) > 2 do
          inner = String.slice(b, 1..-2//1)
          "[" <> lookup(inner) <> "]"
       else
         mod = getEnv(:current_module, "")
         val = if mod != "" and is_binary(b) do
            full = bin(normalizeName(mod)) <> "_" <> b
            key = try do String.to_existing_atom(full) rescue _ -> nil end
            v = if key, do: :application.get_env(:asn1scg, key, :undefined), else: :undefined
            if b == "id-at" do
               :io.format("DEBUG lookup id-at local: ~p -> ~p~n", [full, v])
            end
            v
         else :undefined end

         res = case val do
              :undefined ->
                  v = :application.get_env(:asn1scg, b, b)
                  if b == "id-at" do
                     :io.format("DEBUG lookup id-at global: ~p -> ~p~n", [b, v])
                  end
                  v
              v -> v
         end
         case res do
              a when a == b -> bin(a)
              x -> lookup(x)
         end
       end
   end

   def array_element_type(type_name) when is_binary(type_name) do
     if String.starts_with?(type_name, "[") and String.ends_with?(type_name, "]") do
       String.slice(type_name, 1, String.length(type_name) - 2)
     else
       nil
     end
   end
   def array_element_type(_), do: nil
   def print(format, params), do: :io.format(format, params)


  def fieldType(name, field, {:tag, _, _, _, inner}), do: fieldType(name, field, inner)
  def fieldType(name,field,{:ComponentType,_,_,{:type,_,oc,_,[],:no},_opt,_,_}), do: fieldType(name, field, oc)
  def fieldType(name,field,{:"SEQUENCE", _, _, _, _}), do: bin(name) <> "_" <> bin(field) <> "_Sequence"
  def fieldType(name,field,{:"SET", _, _, _, _}), do: bin(name) <> "_" <> bin(field) <> "_Set"
  def fieldType(name,field,{:"CHOICE",_}), do: bin(name) <> "_" <> bin(field) <> "_Choice"
  def fieldType(name,field,{:"ENUMERATED",_}), do: bin(name) <> "_" <> bin(field) <> "_Enum"
  def fieldType(name,field,{:"INTEGER",_}), do: bin(name) <> "_" <> bin(field) <> "_IntEnum"
  def fieldType(name,field,{:"SEQUENCE OF", type}) do bin = "[#{sequenceOf(name,field,type)}]" ; ASN1.array("#{bin}", partArray(bin), :sequence, "pro #{name}.#{field}") ; bin end
  def fieldType(name,field,{:"Sequence Of", type}) do bin = "[#{sequenceOf(name,field,type)}]" ; ASN1.array("#{bin}", partArray(bin), :sequence, "pro #{name}.#{field}") ; bin end
  def fieldType(name,field,{:"SET OF", {:type, _, {:"SET OF", inner}, _, _, _}}) do
    # Handle nested SET OF SET OF by generating wrapper type
    inner_type = case inner do
      {:type, _, t, _, _, _} -> t
      _ -> inner
    end
    element_name = bin(name) <> "_" <> bin(field) <> "_Element"
    ASN1.array(element_name, substitute_type(lookup(bin(inner_type))), :set, "top")
    element_swift = ASN1.getSwiftName(element_name, getEnv(:current_module, ""))
    "[#{element_swift}]"
  end
  def fieldType(name,field,{:"SET OF", type}) do
    # Check if type contains nested SET OF
    is_nested = case type do
      {:type, _, third, _, _, _} when is_tuple(third) ->
        elem(third, 0) == :"SET OF" or elem(third, 0) == ~c"SET OF"
      _ -> false
    end
    if is_nested do
      {:type, _, {_, inner}, _, _, _} = type
      inner_type = case inner do
        {:type, _, t, _, _, _} -> t
        _ -> inner
      end
      element_name = bin(name) <> "_" <> bin(field) <> "_Element"
      ASN1.array(element_name, substitute_type(lookup(bin(inner_type))), :set, "top")
      element_swift = ASN1.getSwiftName(element_name, getEnv(:current_module, ""))
      "[#{element_swift}]"
    else
      bin = "[#{sequenceOf(name,field,type)}]"
      ASN1.array("#{bin}", partArray(bin), :set, "pro #{name}.#{field}")
      bin
    end
  end
  def fieldType(name,field,{:"Set Of", type}) do bin = "[#{sequenceOf(name,field,type)}]" ; ASN1.array("#{bin}", partArray(bin), :set, "pro #{name}.#{field}") ; bin end
  def fieldType(_,_,{:contentType, {:Externaltypereference,_,_,type}}), do: "#{type}"
  def fieldType(_,_,{:"BIT STRING", _}), do: "ASN1BitString"
  def fieldType(_,_,{:pt, {_,_,_,type}, _}) when is_atom(type), do: "#{substitute_type(lookup(bin(type)))}"
  def fieldType(name, field, {:tag, _, _, _, inner}), do: fieldType(name, field, inner)
  def fieldType(name, field, {:type, _, inner, _, _, _}), do: fieldType(name, field, inner)
  def fieldType(_,_,{:ANY_DEFINED_BY, type}) when is_atom(type), do: "ASN1Any"
  def fieldType(_name,_field,{:Externaltypereference,_,_,type}) when type == :OrganizationalUnitNames, do: "#{substitute_type(lookup(bin(type)))}"
  def fieldType(_name,_field,{:Externaltypereference,_,_,type}), do: "#{substitute_type(lookup(bin(type)))}"
  def fieldType(_,_,{:ObjectClassFieldType,_,_,[{:valuefieldreference, :id}],_}), do: "ASN1ObjectIdentifier"
  def fieldType(_,_,{:ObjectClassFieldType,_,_,_field,_}), do: "ASN1Any"
  def fieldType(_,_,type) when is_atom(type), do: "#{substitute_type(lookup(bin(type)))}"
  def fieldType(name,_,type) when is_tuple(type) do
    case type do
      {:pt, {:Externaltypereference, _, _, actual_type}, _} ->
        "#{substitute_type(lookup(bin(actual_type)))}"
      {:SelectionType, _, {_, _, {:Externaltypereference, _, _, actual_type}, _, _, _}} ->
        "#{substitute_type(lookup(bin(actual_type)))}"
      _ ->
        "#{name}"
    end
  end

  def sequenceOf(name,field,type) do
      sequenceOf2(name,field,type)
  end

  def sequenceOf2(name,field,{:type,_,{:Externaltypereference,_,_,type},_,_,_}), do: "#{sequenceOf(name,field,type)}"
  def sequenceOf2(_,_,{:pt, {:Externaltypereference, _, _, type}, _}), do: substitute_type("#{lookup(bin(type))}")
  def sequenceOf2(name,field,{:type,_,{:"SET OF", {:type, _, {:"SET OF", {:type, _, inner_type, _, _, _}}, _, _, _}},_,_,_}) do
    # Handle nested SET OF SET OF by generating wrapper type
    element_name = bin(name) <> "_" <> bin(field) <> "_Element"
    ASN1.array(element_name, substitute_type(lookup(bin(inner_type))), :set, "top")
    element_swift = ASN1.getSwiftName(element_name, getEnv(:current_module, ""))
    "[#{element_swift}]"
  end
  def sequenceOf2(name,field,{:type,_,{:"SET OF", type},_,_,_}) do
    bin = "[#{sequenceOf(name,field,type)}]" ; ASN1.array("#{bin}", partArray(bin), :set, "arr #{name}.#{field}")
    bin
  end
  def sequenceOf2(name,field,{:type,_,{:"Set Of", type},_,_,_}) do bin = "[#{sequenceOf(name,field,type)}]" ; ASN1.array("#{bin}", partArray(bin), :set, "arr #{name}.#{field}") ; bin  end
  def sequenceOf2(name,field,{:type,_,{:"SEQUENCE OF", type},_,_,_}) do bin = "[#{sequenceOf(name,field,type)}]" ; ASN1.array("#{bin}", partArray(bin), :sequence, "arr #{name}.#{field}") ; bin end
  def sequenceOf2(name,field,{:type,_,{:"Sequence Of", type},_,_,_}) do bin = "[#{sequenceOf(name,field,type)}]" ; ASN1.array("#{bin}", partArray(bin), :sequence, "arr #{name}.#{field}") ; bin end
  def sequenceOf2(name,field,{:type,_,{:CHOICE, cases} = sum,_,_,_}) do
    saveFlag = getEnv("save", false)
    ASN1.choice(fieldType(name,field,sum), cases, getEnv(:current_module, ""), saveFlag)
    bin(name) <> "_" <> bin(field) <> "_Choice"
  end
  def sequenceOf2(name,field,{:type,_,{:SEQUENCE, _, _, _, fields} = product,_,_,_}) do
    saveFlag = getEnv("save", false)
    ASN1.sequence(fieldType(name,field,product), fields, getEnv(:current_module, ""), saveFlag)
    bin(name) <> "_" <> bin(field) <> "_Sequence"
  end
  def sequenceOf2(name,field,{:type,_,{:SET, _, _, _, fields} = _product,_,_,_}) do
      saveFlag = getEnv("save", false)
      typeName = bin(name) <> "_" <> bin(field) <> "_Set"
      ASN1.set(typeName, fields, getEnv(:current_module, ""), saveFlag)
      typeName
  end
  def sequenceOf2(name,field,{:type,_,type,_,_,_}) do "#{sequenceOf(name,field,type)}" end
  def sequenceOf2(name,_,{:Externaltypereference, _, _, type}) do :application.get_env(:asn1scg, bin(name), bin(type)) end
  def sequenceOf2(_,_,{:ObjectClassFieldType,_,_,[{:valuefieldreference, :id}],_}), do: "ASN1ObjectIdentifier"
  def sequenceOf2(_,_,{:ObjectClassFieldType,_,_,_field,_}), do: "ASN1Any"
  def sequenceOf2(_,_,x) when is_tuple(x), do: substitute_type("#{bin(:erlang.element(1, x))}")
  def sequenceOf2(_,_,x) when is_atom(x), do: substitute_type("#{lookup(x)}")
  def sequenceOf2(_,_,x) when is_binary(x), do: substitute_type("#{lookup(x)}")

end
